<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>All Nodes Distance K in Binary Tree</title>
    <style type="text/css">
        body, table { font-family: Helvetica, Arial, sans-serif; font-size: 13px; }
        a { color: #006DBA; }
    </style>
    <!--NUMBER--amyrbmkq--NUMBER-->
    <!--TYPE--PlainText--TYPE-->
    <!--PERMISSION--Readonly--PERMISSION-->
    <!--ACCESS--Public--ACCESS-->
    <!--PASSWORD----PASSWORD-->
    <!--STATUS--Active--STATUS-->
    <!--QUICKEDIT--False--QUICKEDIT-->
    <!--QUICKEDITPASSWORD----QUICKEDITPASSWORD-->
    <!--DATECREATED--2022-04-27 09:04:26--DATECREATED-->
    <!--DATEUPDATED--2022-04-27 09:04:26--DATEUPDATED-->
    <!--LABELS----LABELS-->
</head>
<body>
<h2>All Nodes Distance K in Binary Tree</h2>
<anotepad><pre>void solve( unordered_map<TreeNode*,TreeNode*>&mp,TreeNode* root, TreeNode* target, int k)
   {
       queue<TreeNode*>q;
       q.push(root);
       while(!q.empty())
       {
          TreeNode* node=q.front();
           q.pop();
           if(node->left)
           {
               mp[node->left]=node;
               q.push(node->left);
           }
           if(node->right)
           {
               mp[node->right]=node;
               q.push(node->right);
           }
       }
   }
    
    vector<int> distanceK(TreeNode* root, TreeNode* target, int k) {
       unordered_map<TreeNode*,TreeNode*>mp;
        solve(mp,root,target,k);
        queue<TreeNode*>q1;
       unordered_map<TreeNode*,bool>vis;
        q1.push(target);
        int cnt=0;
        vis[target]=true;
        while(!q1.empty())
        {
            int s=q1.size();
            
            if(cnt==k)
            {
                break;
            }
            cnt++;
            for(int i=0;i<s;i++)
            {
                TreeNode* n1=q1.front();
                q1.pop();
                if(n1->left && vis[n1->left]!=true)
                {
                    q1.push(n1->left);
                    vis[n1->left]=true;
                }
                if(n1->right && vis[n1->right]!=true)
                {
                    q1.push(n1->right);
                    vis[n1->right]=true;
                }
                if(mp[n1] && vis[mp[n1]]!=true)
                {
                    q1.push(mp[n1]);
                    vis[mp[n1]]=true;
                }
            }
        }
        vector<int>res;
        while(!q1.empty())
        {
            TreeNode* t=q1.front();
            q1.pop();
            res.push_back(t->val);
        }
        return res;
    }</pre></anotepad>
</body>
</html>